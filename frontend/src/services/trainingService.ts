// Training Service - Comprehensive service for all training and training operations
import { supabase } from '../config/supabase';
import { UserProfile, TrainingPlan } from '../types';
import { API_CONFIG } from '../constants/api';
import { mapProfileToBackendRequest } from '../utils/profileDataMapping';
import { 
  GenerateTrainingPlanRequest, 
  GenerateTrainingPlanResponse,
  ApiResponse 
} from '../types/api';
import { 
  TrainingPlan as TrainingTrainingPlan, 
  DailyTraining, 
  Exercise, 
  TrainingExercise, 
  TrainingSet,
  TrainingPlanResponse,
  ExerciseResponse,
  UpdateSetResponse,
  CompleteTrainingResponse
} from '../types/training';

export interface TrainingServiceResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

export class TrainingService {
  // ============================================================================
  // WORKOUT PLAN MANAGEMENT
  // ============================================================================

  /**
   * Generate a training plan using the backend API
   */
  static async generateTrainingPlan(
    profileData: any,
    userProfileId: number,
    userId: string
  ): Promise<TrainingServiceResponse<TrainingTrainingPlan>> {
    console.log('üöÄ Generating training plan...');

    try {
      const requestBody: GenerateTrainingPlanRequest = mapProfileToBackendRequest(profileData, userId, userProfileId);

      // Get JWT token from Supabase session
      const { data: { session } } = await supabase.auth.getSession();
      const authToken = session?.access_token;

      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
      };

      if (authToken) {
        headers['Authorization'] = `Bearer ${authToken}`;
      }

      const apiUrl = `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.GENERATE_WORKOUT_PLAN}`;

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers,
        body: JSON.stringify(requestBody),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå API error:', response.status, response.statusText, errorText);
        return {
          success: false,
          error: `API Error: ${response.status} ${response.statusText}`,
        };
      }

      const result: GenerateTrainingPlanResponse = await response.json();

      if (result.status === 'success') {
        console.log('‚úÖ Training plan generated by backend');
        
        // Instead of parsing the API response, fetch the complete training plan from Supabase
        // This ensures we get all the proper IDs, relationships, and formatted data
        const trainingPlanResult = await this.getTrainingPlan(userProfileId);
        
        if (trainingPlanResult.success && trainingPlanResult.data) {
          console.log('‚úÖ Training plan fetched from database');
          return {
            success: true,
            data: trainingPlanResult.data,
          };
        } else {
          console.error('‚ùå Failed to fetch generated training plan from database');
          return {
            success: false,
            error: 'Training plan was generated but could not be retrieved',
          };
        }
      } else {
        console.error('‚ùå Generation failed - invalid response');
        return {
          success: false,
          error: result.message || 'Failed to generate training plan',
        };
      }
    } catch (error) {
      console.error('üí• Generation error:', error instanceof Error ? error.message : String(error));
      return {
        success: false,
        error: error instanceof Error ? error.message : 'An unexpected error occurred',
      };
    }
  }

  /**
   * Get training plan for a user (with proper exercise data mapping)
   */
  static async getTrainingPlan(userProfileId: number): Promise<TrainingServiceResponse<TrainingTrainingPlan>> {
    console.log('üîç TrainingService: Starting training plan fetch...', {
      userProfileId,
      timestamp: new Date().toISOString()
    });

    try {
      // Use relational query to get training plan with all exercise details
      console.log('üìä TrainingService: Fetching training plan with relational query...');
      const { data, error } = await supabase
        .from('training_plans')
        .select(`
          *,
          weekly_schedules (
            *,
            daily_training (
              *,
              strength_exercise (
                *,
                exercises (*)
              ),
              endurance_session (*)
            )
          )
        `)
        .eq('user_profile_id', userProfileId)
        .single();


      if (error) {
        if (error.code === 'PGRST116') {
          console.log('‚ÑπÔ∏è TrainingService: No training plan found (PGRST116) - this is expected for new users');
          return {
            success: false,
            error: 'No training plan found',
          };
        }
        
        // Only log errors for actual network/database issues, not for "no data found"
        console.error('‚ùå TrainingService: Relational query failed:', error);
        console.error('‚ùå TrainingService: Error details:', {
          code: error.code,
          message: error.message,
          details: error.details,
          hint: error.hint,
          timestamp: new Date().toISOString()
        });
        
        return {
          success: false,
          error: `Database error: ${error.message}`,
        };
      }

      if (!data) {
        console.log('‚ùå TrainingService: No data returned from query');
        return { success: false, error: 'No active training plan found' };
      }

      console.log('‚úÖ TrainingService: Successfully fetched training plan data:', {
        id: data.id,
        title: data.title,
        user_profile_id: data.user_profile_id,
        has_weekly_schedules: !!data.weekly_schedules,
        weekly_schedules_count: data.weekly_schedules?.length || 0
      });

      // Debug: Check the nested data structure
      if (data.weekly_schedules && data.weekly_schedules.length > 0) {
        const firstWeek = data.weekly_schedules[0];
        console.log('üìÖ TrainingService: First week data:', {
          week_id: firstWeek.id,
          week_number: firstWeek.week_number,
          has_daily_trainings: !!firstWeek.daily_training,
          daily_trainings_count: firstWeek.daily_training?.length || 0
        });

        if (firstWeek.daily_training && firstWeek.daily_training.length > 0) {
          const firstDay = firstWeek.daily_training[0];
          console.log('üèÉ TrainingService: First day data:', {
            day_id: firstDay.id,
            day_of_week: firstDay.day_of_week,
            is_rest_day: firstDay.is_rest_day,
            has_strength_exercises: !!firstDay.strength_exercise,
            strength_exercises_count: firstDay.strength_exercise?.length || 0,
            has_endurance_sessions: !!firstDay.endurance_session,
            endurance_sessions_count: firstDay.endurance_session?.length || 0
          });

          if (firstDay.strength_exercise && firstDay.strength_exercise.length > 0) {
            const firstExercise = firstDay.strength_exercise[0];
            console.log('üí™ TrainingService: First exercise data:', {
              strength_exercise_id: firstExercise.id,
              exercise_id: firstExercise.exercise_id,
              has_exercises_data: !!firstExercise.exercises,
              exercise_name: firstExercise.exercises?.name || 'NO NAME',
              exercise_data: firstExercise.exercises
            });
          }

        }
      }

      // Transform the relational data to match our TrainingTrainingPlan interface
      const trainingPlan: TrainingTrainingPlan = {
        id: data.id.toString(),
        title: data.title,
        description: data.summary,
        totalWeeks: data.weekly_schedules?.length || 1,
        currentWeek: data.current_week || 1,
        aiMessage: data.ai_message,
        weeklySchedules: data.weekly_schedules?.map((schedule: any) => {
          // Sort daily trainings by day order (Monday = 0, Tuesday = 1, etc.) - Monday-first week
          const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
          const sortedDailyTrainings = schedule.daily_training?.sort((a: any, b: any) => {
            const aIndex = dayOrder.indexOf(a.day_of_week);
            const bIndex = dayOrder.indexOf(b.day_of_week);
            return aIndex - bIndex;
          }) || [];

          return {
            id: schedule.id.toString(),
            weekNumber: schedule.week_number,
            dailyTrainings: sortedDailyTrainings.map((daily: any) => {
                // Combine strength exercises and endurance sessions from relational data
                const strengthExercises = daily.strength_exercise?.map((se: any) => ({
                    id: se.id.toString(),
                    exerciseId: se.exercise_id.toString(),
                    completed: se.completed,
                    order: se.order || 0,
                    exercise: se.exercises ? {
                      id: se.exercises.id.toString(),
                      name: se.exercises.name,
                      force: se.exercises.force,
                      instructions: se.exercises.instructions,
                      equipment: se.exercises.equipment,
                      target_area: se.exercises.target_area,
                      secondary_muscles: se.exercises.secondary_muscles,
                      main_muscles: se.exercises.main_muscles,
                      difficulty: se.exercises.difficulty,
                      exercise_tier: se.exercises.exercise_tier,
                      preparation: se.exercises.preparation,
                      execution: se.exercises.execution,
                      tips: se.exercises.tips
                    } : null,
                    // Extract equipment and mainMuscle - prefer from strength_exercise table (AI-generated), fallback to exercises table
                    equipment: se.equipment || se.exercises?.equipment || 'Bodyweight',
                    mainMuscle: se.main_muscle || se.exercises?.main_muscles?.[0] || null,
                    exerciseName: se.exercise_name || se.exercises?.name || 'Unknown Exercise',
                    sets: this.parseSets(se.sets, se.reps, se.weight),
                    weight1RM: se.weight_1rm
                  })) || [];

                // Map endurance sessions to proper format
                const enduranceSessions = daily.endurance_session?.map((es: any, index: number) => {
                  return {
                    id: es.id.toString(),
                    exerciseId: `endurance_${es.id}`,
                    completed: es.completed || false,
                    order: strengthExercises.length + index,
                    enduranceSession: {
                      id: es.id.toString(),
                      name: es.name || `${es.sport_type} - ${es.training_volume} ${es.unit}`,
                      description: es.description || `${es.sport_type} session`,
                      sportType: es.sport_type,
                      trainingVolume: es.training_volume,
                      unit: es.unit,
                      heartRateZone: es.heart_rate_zone,
                      intensity: es.intensity,
                      completed: es.completed || false
                    }
                  };
                }) || [];

                const allExercises = [...strengthExercises, ...enduranceSessions];

                return {
                  id: daily.id.toString(),
                  dayOfWeek: daily.day_of_week,
                  isRestDay: daily.is_rest_day,
                  exercises: allExercises,
                  completed: allExercises.every((ex: any) => ex.completed) || daily.is_rest_day
                };
            }) || [],
            completed: schedule.daily_training?.every((daily: any) => {
              if (daily.is_rest_day) return true;
              const strengthCompleted = daily.strength_exercise?.every((ex: any) => ex.completed) ?? true;
              const enduranceCompleted = daily.endurance_session?.every((ex: any) => ex.completed) ?? true;
              return strengthCompleted && enduranceCompleted;
            }) || false,
            completedAt: schedule.completed_at ? new Date(schedule.completed_at) : undefined
          };
        }) || [],
        createdAt: new Date(data.created_at),
        updatedAt: new Date(data.updated_at),
        completed: data.completed || false,
        completedAt: data.completed_at ? new Date(data.completed_at) : undefined
      };

      return {
        success: true,
        data: trainingPlan,
      };
    } catch (error) {
      console.error('üí• TrainingService: Unexpected error fetching training plan:', error);
      return {
        success: false,
        error: 'An unexpected error occurred while fetching your training plan',
      };
    }
  }

  /**
   * Delete a training plan
   */
  static async deleteTrainingPlan(trainingPlanId: number): Promise<TrainingServiceResponse<void>> {
    try {
      const { error } = await supabase
        .from('training_plans')
        .delete()
        .eq('id', trainingPlanId);

      if (error) {
        console.error('‚ùå TrainingService: Error deleting training plan:', error);
        return {
          success: false,
          error: `Failed to delete training plan: ${error.message}`,
        };
      }

      return {
        success: true,
      };
    } catch (error) {
      console.error('üí• TrainingService: Unexpected error deleting training plan:', error);
      return {
        success: false,
        error: 'An unexpected error occurred while deleting your training plan',
      };
    }
  }

  // ============================================================================
  // EXERCISE TRACKING & WORKOUT OPERATIONS
  // ============================================================================

  /**
   * Update set details (reps, weight) for a specific exercise
   */
  static async updateSetDetails(
    exerciseId: string, 
    setIndex: number, 
    reps: number, 
    weight: number
  ): Promise<UpdateSetResponse> {
    try {
      // First, get the current strength exercise data
      const { data: strengthExercise, error: fetchError } = await supabase
        .from('strength_exercise')
        .select('*')
        .eq('id', exerciseId)
        .single();

      if (fetchError) {
        console.error('Error fetching strength exercise:', fetchError);
        return { success: false, error: fetchError.message };
      }

      // Update the reps and weight arrays
      const updatedReps = [...strengthExercise.reps];
      const updatedWeight = [...strengthExercise.weight];
      
      updatedReps[setIndex] = reps;
      updatedWeight[setIndex] = weight;

      // Update the database
      const { data, error } = await supabase
        .from('strength_exercise')
        .update({
          reps: updatedReps,
          weight: updatedWeight,
          updated_at: new Date().toISOString()
        })
        .eq('id', exerciseId)
        .select()
        .single();

      if (error) {
        console.error('Error updating set details:', error);
        return { success: false, error: error.message };
      }

      // Create the updated TrainingSet object
      const updatedSet: TrainingSet = {
        id: `${exerciseId}-${setIndex}`,
        reps: reps,
        weight: weight,
        completed: true,
        restTime: 60 // Default rest time
      };

      return { success: true, data: updatedSet };
    } catch (error) {
      console.error('Error in updateSetDetails:', error);
      return { success: false, error: 'Failed to update set details' };
    }
  }

  /**
   * Update endurance session intensity in database
   */
  static async updateEnduranceIntensity(exerciseId: string, intensity: number): Promise<{ success: boolean; error?: string }> {
    try {
      const { data, error } = await supabase
        .from('endurance_session')
        .update({
          intensity: intensity,
          updated_at: new Date().toISOString()
        })
        .eq('id', exerciseId)
        .select()
        .single();

      if (error) {
        console.error('Error updating endurance intensity:', error);
        return { success: false, error: error.message };
      }

      console.log(`‚úÖ Endurance session ${exerciseId} intensity updated to: ${intensity}`);
      return { success: true };
    } catch (error) {
      console.error('Error in updateEnduranceIntensity:', error);
      return { success: false, error: 'Failed to update endurance intensity' };
    }
  }

  /**
   * Update exercise completion status in database
   */
  static async updateExerciseCompletion(exerciseId: string, completed: boolean): Promise<{ success: boolean; error?: string }> {
    try {
      // Try strength_exercise first
      const { data: strengthData, error: strengthError } = await supabase
        .from('strength_exercise')
        .update({
          completed: completed,
          updated_at: new Date().toISOString()
        })
        .eq('id', exerciseId)
        .select()
        .single();

      if (!strengthError && strengthData) {
        console.log(`‚úÖ Strength exercise ${exerciseId} completion updated to: ${completed}`);
        return { success: true };
      }

      // If not found in strength_exercise, try endurance_session
      const { data: enduranceData, error: enduranceError } = await supabase
        .from('endurance_session')
        .update({
          completed: completed,
          updated_at: new Date().toISOString()
        })
        .eq('id', exerciseId)
        .select()
        .single();

      if (enduranceError) {
        console.error('Error updating exercise completion:', enduranceError);
        return { success: false, error: enduranceError.message };
      }

      console.log(`‚úÖ Endurance session ${exerciseId} completion updated to: ${completed}`);
      return { success: true };
    } catch (error) {
      console.error('Error in updateExerciseCompletion:', error);
      return { success: false, error: 'Failed to update exercise completion' };
    }
  }

  /**
   * Toggle exercise completion status (DEPRECATED - now handled in frontend)
   * This function is kept for backward compatibility but is no longer used
   */
  static async toggleExerciseCompletion(exerciseId: string): Promise<{ success: boolean; error?: string }> {
    console.warn('toggleExerciseCompletion is deprecated - exercise completion is now handled in frontend');
    return { success: true };
  }


  /**
   * Complete a daily training
   */
  static async completeDailyTraining(
    dailyTrainingId: string
  ): Promise<CompleteTrainingResponse> {
    try {
      const { data, error } = await supabase
        .from('daily_training')
        .update({
          updated_at: new Date().toISOString()
        })
        .eq('id', dailyTrainingId)
        .select()
        .single();

      if (error) {
        console.error('Error completing daily training:', error);
        return { success: false, error: error.message };
      }

      return { 
        success: true, 
        data: {
          trainingId: dailyTrainingId
        }
      };
    } catch (error) {
      console.error('Error in completeDailyTraining:', error);
      return { success: false, error: 'Failed to complete daily training' };
    }
  }

  /**
   * Get exercise details by ID
   */
  static async getExerciseDetails(exerciseId: string): Promise<ExerciseResponse> {
    try {
      const { data, error } = await supabase
        .from('exercises')
        .select('*')
        .eq('id', exerciseId)
        .single();

      if (error) {
        console.error('Error fetching exercise details:', error);
        return { success: false, error: error.message };
      }

      const exercise: Exercise = {
        id: data.id.toString(),
        name: data.name,
        force: data.force,
        instructions: data.instructions,
        equipment: data.equipment,
        target_area: data.target_area,
        secondary_muscles: data.secondary_muscles,
        main_muscles: data.main_muscles,
        difficulty: data.difficulty,
        exercise_tier: data.tier,
        preparation: data.preparation,
        execution: data.execution,
        tips: data.tips
      };

      return { success: true, data: [exercise] };
    } catch (error) {
      console.error('Error in getExerciseDetails:', error);
      return { success: false, error: 'Failed to fetch exercise details' };
    }
  }

  /**
   * Get training history for a user
   */
  static async getTrainingHistory(userId: string, limit: number = 10): Promise<{ success: boolean; data?: DailyTraining[]; error?: string }> {
    try {
      const { data, error } = await supabase
        .from('daily_training')
        .select(`
          *,
          strength_exercise (
            *,
            exercises (*)
          ),
          endurance_session (*)
        `)
        .eq('completed', true)
        .order('completed_at', { ascending: false })
        .limit(limit);

      if (error) {
        console.error('Error fetching training history:', error);
        return { success: false, error: error.message };
      }

      const history: DailyTraining[] = data.map((daily: any) => {
        const strengthExercises = daily.strength_exercise?.map((se: any) => ({
          id: se.id.toString(),
          exerciseId: se.exercise_id.toString(),
          exercise: {
            id: se.exercises.id.toString(),
            name: se.exercises.name,
            force: se.exercises.force,
            instructions: se.exercises.instructions,
            equipment: se.exercises.equipment,
            target_area: se.exercises.target_area,
            secondary_muscles: se.exercises.secondary_muscles,
            main_muscles: se.exercises.main_muscles,
            difficulty: se.exercises.difficulty,
            exercise_tier: se.exercises.exercise_tier,
            preparation: se.exercises.preparation,
            execution: se.exercises.execution,
            tips: se.exercises.tips
          },
          sets: this.parseSets(se.sets, se.reps, se.weight),
          completed: se.completed,
          order: se.order || 0
        })) || [];

        const enduranceSessions = daily.endurance_session?.map((es: any, index: number) => ({
          id: es.id.toString(),
          exerciseId: `endurance_${es.id}`,
          exercise: {
            id: `endurance_${es.id}`,
            name: es.name || `${es.sport_type} - ${es.training_volume} ${es.unit}`,
            force: null,
            instructions: es.description || `${es.sport_type} session`,
            equipment: null,
            target_area: 'Endurance',
            secondary_muscles: [],
            main_muscles: [],
            difficulty: null,
            imageUrl: null,
            videoUrl: null
          },
          intensity: es.intensity || null,
          sets: [],
          completed: es.completed || false,
          order: strengthExercises.length + index
        })) || [];

        return {
          id: daily.id.toString(),
          dayOfWeek: daily.day_of_week,
          isRestDay: daily.is_rest_day,
          exercises: [...strengthExercises, ...enduranceSessions],
        };
      });

      return { success: true, data: history };
    } catch (error) {
      console.error('Error in getTrainingHistory:', error);
      return { success: false, error: 'Failed to fetch training history' };
    }
  }

  // ============================================================================
  // HOME SCREEN DATA METHODS
  // ============================================================================

  /**
   * Get training streak (consecutive days with completed trainings)
   */
  static async getTrainingStreak(userProfileId: number): Promise<TrainingServiceResponse<number>> {
    try {
      // Get training plan with relational data
      const { data: trainingPlan, error } = await supabase
        .from('training_plans')
        .select(`
          *,
          weekly_schedules (
            *,
            daily_training (
              *,
              strength_exercise (
                *,
                exercises (*)
              ),
              endurance_session (*)
            )
          )
        `)
        .eq('user_profile_id', userProfileId)
        .single();

      if (error || !trainingPlan) {
        return { success: true, data: 0 };
      }

      // Calculate streak from relational data across all weeks
      let streak = 0;
      const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
      
      if (!trainingPlan.weekly_schedules || trainingPlan.weekly_schedules.length === 0) {
        console.log('‚ùå getTrainingStreak - No weekly schedules found');
        return { success: true, data: 0 };
      }

      // Get all daily trainings from all weeks, sorted by week number and day order
      const allTrainings: any[] = [];
      
      trainingPlan.weekly_schedules
        .sort((a: any, b: any) => b.week_number - a.week_number) // Most recent week first
        .forEach((week: any) => {
          if (week.daily_training) {
            // Sort daily trainings by day order (most recent first within each week)
            const sortedDailyTrainings = week.daily_training.sort((a: any, b: any) => {
              const aIndex = dayOrder.indexOf(a.day_of_week);
              const bIndex = dayOrder.indexOf(b.day_of_week);
              return bIndex - aIndex;
            });
            
            allTrainings.push(...sortedDailyTrainings);
          }
        });

      // Calculate streak by going through all trainings chronologically
      for (const training of allTrainings) {
        if (training.is_rest_day) continue; // Skip rest days
        
        // Check if all exercises in this training are completed
        const strengthCompleted = training.strength_exercise?.every((ex: any) => ex.completed) ?? true;
        const enduranceCompleted = training.endurance_session?.every((ex: any) => ex.completed) ?? true;
        const allExercisesCompleted = strengthCompleted && enduranceCompleted;
        
        if (allExercisesCompleted) {
          streak++;
        } else {
          break; // Streak broken - stop counting
        }
      }

      return { success: true, data: streak };
    } catch (error) {
      console.error('üí• TrainingService: Error calculating streak:', error);
      return { success: false, error: 'Failed to calculate training streak' };
    }
  }

  /**
   * Get weekly training count (total planned trainings in current week)
   */
  static async getWeeklyTrainingCount(userProfileId: number): Promise<TrainingServiceResponse<number>> {
    try {
      // Get training plan with relational data
      const { data: trainingPlan, error } = await supabase
        .from('training_plans')
        .select(`
          *,
          weekly_schedules (
            *,
            daily_training (
              *,
              strength_exercise (
                *,
                exercises (*)
              ),
              endurance_session (*)
            )
          )
        `)
        .eq('user_profile_id', userProfileId)
        .single();

      if (error || !trainingPlan) {
        return { success: true, data: 0 };
      }

      // Get current week's schedule
      const targetWeek = trainingPlan.current_week || 1;
      const currentWeek = trainingPlan.weekly_schedules?.find((week: any) => 
        week.week_number === targetWeek
      );
      
      if (!currentWeek?.daily_training) {
        return { success: true, data: 0 };
      }

      // Count all planned trainings in current week (non-rest days)
      const totalTrainings = currentWeek.daily_training.filter((training: any) => !training.is_rest_day).length;
      return { success: true, data: totalTrainings };
    } catch (error) {
      console.error('üí• TrainingService: Error calculating weekly trainings:', error);
      return { success: false, error: 'Failed to calculate weekly training count' };
    }
  }

  /**
   * Get goal progress (percentage of completed trainings)
   */
  static async getGoalProgress(userProfileId: number): Promise<TrainingServiceResponse<number>> {
    try {
      // Get training plan with relational data
      const { data: trainingPlan, error } = await supabase
        .from('training_plans')
        .select(`
          *,
          weekly_schedules (
            *,
            daily_training (
              *,
              strength_exercise (
                *,
                exercises (*)
              ),
              endurance_session (*)
            )
          )
        `)
        .eq('user_profile_id', userProfileId)
        .single();

      if (error || !trainingPlan) {
        return { success: true, data: 0 };
      }

      // Get current week's schedule
      const targetWeek = trainingPlan.current_week || 1;
      const currentWeek = trainingPlan.weekly_schedules?.find((week: any) => 
        week.week_number === targetWeek
      );
      
      if (!currentWeek?.daily_training) {
        return { success: true, data: 0 };
      }

      const totalTrainingDays = currentWeek.daily_training.filter((training: any) => !training.is_rest_day).length;
      const completedTrainingDays = currentWeek.daily_training.filter((training: any) => {
        if (training.is_rest_day) return false;
        const strengthCompleted = training.strength_exercise?.every((ex: any) => ex.completed) ?? true;
        const enduranceCompleted = training.endurance_session?.every((ex: any) => ex.completed) ?? true;
        return strengthCompleted && enduranceCompleted;
      }).length;

      const progress = totalTrainingDays > 0 ? Math.round((completedTrainingDays / totalTrainingDays) * 100) : 0;
      return { success: true, data: progress };
    } catch (error) {
      console.error('üí• TrainingService: Error calculating goal progress:', error);
      return { success: false, error: 'Failed to calculate goal progress' };
    }
  }

  /**
   * Get today's training with exercises
   */
  static async getTodaysTraining(userProfileId: number): Promise<TrainingServiceResponse<any>> {
    try {
      const today = new Date();
      const dayNames = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
      const todayName = dayNames[today.getDay()];

      // Get training plan with relational data
      const { data: trainingPlan, error } = await supabase
        .from('training_plans')
        .select(`
          *,
          weekly_schedules (
            *,
            daily_training (
              *,
              strength_exercise (
                *,
                exercises (*)
              ),
              endurance_session (*)
            )
          )
        `)
        .eq('user_profile_id', userProfileId)
        .single();

      if (error || !trainingPlan) {
        console.log('‚ÑπÔ∏è No training plan found');
        return { success: true, data: null };
      }

      // Get current week's schedule - fallback to first week if current_week is undefined
      const targetWeek = trainingPlan.current_week || 1;
      
      const currentWeek = trainingPlan.weekly_schedules?.find((week: any) => 
        week.week_number === targetWeek
      );
      
      if (!currentWeek?.daily_training) {
        console.log('‚ùå getTodaysTraining - No current week or daily trainings found');
        return { success: true, data: null };
      }

      // Find today's training
      const todaysTraining = currentWeek.daily_training.find((training: any) => 
        training.day_of_week === todayName
      );

      if (!todaysTraining) {
        return { success: true, data: null };
      }

      // Transform the data to match component expectations
      const strengthExercises = todaysTraining.strength_exercise?.map((se: any) => ({
        id: se.id?.toString() || Math.random().toString(),
        name: se.exercises?.name || 'Unknown Exercise',
        completed: se.completed || false,
        sets: se.sets || 1,
        reps: se.reps || [10],
        weight: se.weight || [null],
        weight1rm: se.weight_1rm || [70],
      })) || [];

      const enduranceSessions = todaysTraining.endurance_session?.map((es: any) => ({
        id: es.id?.toString() || Math.random().toString(),
        name: es.name || `${es.sport_type} - ${es.training_volume} ${es.unit}`,
        completed: es.completed || false,
        sets: 1,
        reps: [],
        weight: [],
        weight1rm: [],
      })) || [];

      const transformedTraining = {
        id: todaysTraining.id || todayName,
        name: `${todayName} Training`,
        isRestDay: todaysTraining.is_rest_day,
        exercises: [...strengthExercises, ...enduranceSessions],
      };

      return { success: true, data: transformedTraining };
    } catch (error) {
      console.error('üí• TrainingService: Error fetching today\'s training:', error);
      return { success: false, error: 'Failed to fetch today\'s training' };
    }
  }

  /**
   * Get recent completed trainings (last 3)
   */
  static async getRecentActivity(userProfileId: number): Promise<TrainingServiceResponse<any[]>> {
    try {
      // Get training plan with relational data
      const { data: trainingPlan, error } = await supabase
        .from('training_plans')
        .select(`
          *,
          weekly_schedules (
            *,
            daily_training (
              *,
              strength_exercise (
                *,
                exercises (*)
              ),
              endurance_session (*)
            )
          )
        `)
        .eq('user_profile_id', userProfileId)
        .single();

      if (error || !trainingPlan) {
        return { success: true, data: [] };
      }

      // Get current week's schedule
      const targetWeek = trainingPlan.current_week || 1;
      const currentWeek = trainingPlan.weekly_schedules?.find((week: any) => 
        week.week_number === targetWeek
      );
      
      if (!currentWeek?.daily_training) {
        return { success: true, data: [] };
      }

      // Filter and transform completed trainings (only where ALL exercises are completed)
      const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
      
      const recentActivities = currentWeek.daily_training
        .filter((training: any) => {
          // Only get training days, not rest days
          if (training.is_rest_day) return false;
          
          // Check if all exercises in this training are completed
          const strengthCompleted = training.strength_exercise?.every((ex: any) => ex.completed) ?? true;
          const enduranceCompleted = training.endurance_session?.every((ex: any) => ex.completed) ?? true;
          return strengthCompleted && enduranceCompleted;
        })
        .sort((a: any, b: any) => {
          // Sort by day order (most recent first)
          const aIndex = dayOrder.indexOf(a.day_of_week);
          const bIndex = dayOrder.indexOf(b.day_of_week);
          return bIndex - aIndex;
        })
        .slice(0, 3) // Take only last 3 completed trainings
        .map((training: any, index: number) => {
          const exerciseCount = (training.strength_exercise?.length || 0) + (training.endurance_session?.length || 0);
          return {
            id: training.id?.toString() || training.day_of_week,
            type: 'training' as const,
            title: `${training.day_of_week} Training`,
            subtitle: `${exerciseCount} exercises ‚Ä¢ 45 minutes ‚Ä¢ 320 calories`, // Dummy data as requested
            date: index === 0 ? 'Yesterday' : index === 1 ? '2 days ago' : '3 days ago',
            duration: '45 min',
            calories: 320,
          };
        });

      return { success: true, data: recentActivities };
    } catch (error) {
      console.error('üí• TrainingService: Error fetching recent activity:', error);
      return { success: false, error: 'Failed to fetch recent activity' };
    }
  }

  // ============================================================================
  // UTILITY METHODS
  // ============================================================================

  /**
   * Helper method to parse sets from database arrays
   */
  private static parseSets(setsCount: number, reps: number[], weight: number[]): TrainingSet[] {
    const sets: TrainingSet[] = [];
    for (let i = 0; i < setsCount; i++) {
      sets.push({
        id: `set-${i}`,
        reps: reps[i] || 0,
        weight: weight[i] || 0,
        completed: reps[i] > 0 && weight[i] > 0,
        restTime: 60
      });
    }
    return sets;
  }

  /**
   * Calculate 1RM using Epley formula
   */
  static calculateOneRM(weight: number, reps: number): number {
    if (reps <= 0 || weight <= 0) return 0;
    if (reps === 1) return weight;
    
    // Epley formula: 1RM = weight * (1 + reps/30)
    return Math.round(weight * (1 + reps / 30));
  }

  /**
   * Calculate training progress percentage
   */
  static calculateTrainingProgress(exercises: TrainingExercise[]): number {
    if (exercises.length === 0) return 0;
    
    const completedExercises = exercises.filter(ex => ex.completed).length;
    return Math.round((completedExercises / exercises.length) * 100);
  }

  /**
   * Calculate weekly progress
   */
  static calculateWeeklyProgress(dailyTrainings: DailyTraining[]): number {
    if (dailyTrainings.length === 0) return 0;
    
    const completedTrainings = dailyTrainings.filter(training => training.completed).length;
    return Math.round((completedTrainings / dailyTrainings.length) * 100);
  }

  // ============================================================================
  // DAILY FEEDBACK (ACE PATTERN)
  // ============================================================================

  /**
   * Submit daily training feedback with optional skip
   */
  static async submitDailyFeedback(feedbackData: {
    daily_training_id: number;
    user_id: string;
    plan_id: string;
    week_number: number;
    day_of_week: string;
    training_date: string;
    training_type: string;
    original_training: any;
    actual_training: any;
    session_completed: boolean;
    completion_percentage: number;
    feedback_provided: boolean;
    user_rating?: number;
    user_feedback?: string;
    energy_level?: number;
    difficulty?: number;
    enjoyment?: number;
    soreness_level?: number;
    injury_reported?: boolean;
    injury_description?: string;
    pain_location?: string;
    avg_heart_rate?: number;
    max_heart_rate?: number;
    performance_metrics?: any;
    personal_info: any;
  }): Promise<TrainingServiceResponse<{
    lessons_generated: number;
    lessons_added: number;
    lessons_updated: number;
    modifications_detected: number;
    total_lessons: number;
    training_status_updated: boolean;
  }>> {
    try {
      console.log('üìù Submitting daily training feedback...');

      // Get JWT token from Supabase session
      const { data: { session } } = await supabase.auth.getSession();
      const authToken = session?.access_token;

      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
      };

      if (authToken) {
        headers['Authorization'] = `Bearer ${authToken}`;
      }

      const apiUrl = `${API_CONFIG.BASE_URL}/training/daily-training-feedback`;

      const requestBody = {
        ...feedbackData,
        jwt_token: authToken,
      };

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers,
        body: JSON.stringify(requestBody),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå Daily feedback API error:', response.status, response.statusText, errorText);
        return {
          success: false,
          error: `API Error: ${response.status} ${response.statusText}`,
        };
      }

      const result = await response.json();

      if (result.success) {
        console.log('‚úÖ Daily feedback submitted successfully');
        console.log(`   ‚Ä¢ Lessons generated: ${result.data.lessons_generated}`);
        console.log(`   ‚Ä¢ Lessons added: ${result.data.lessons_added}`);
        console.log(`   ‚Ä¢ Modifications detected: ${result.data.modifications_detected}`);
        console.log(`   ‚Ä¢ Total lessons in playbook: ${result.data.total_lessons}`);

        return {
          success: true,
          data: result.data,
        };
      } else {
        console.error('‚ùå Daily feedback submission failed:', result.message);
        return {
          success: false,
          error: result.message || 'Failed to submit daily feedback',
        };
      }
    } catch (error) {
      console.error('üí• Daily feedback error:', error instanceof Error ? error.message : String(error));
      return {
        success: false,
        error: error instanceof Error ? error.message : 'An unexpected error occurred',
      };
    }
  }

  /**
   * Compare original vs actual training to detect modifications
   * This is a helper method for the frontend to prepare data for daily feedback
   */
  static detectTrainingModifications(
    originalTraining: DailyTraining,
    actualTraining: DailyTraining
  ): any {
    const modifications = {
      strength_exercises: originalTraining.exercises
        .filter(ex => ex.exercise && ex.sets)
        .map(origEx => {
          const actualEx = actualTraining.exercises.find(ae => ae.exerciseId === origEx.exerciseId);
          
          if (!actualEx) {
            return null; // Exercise was removed
          }

          return {
            exercise_id: parseInt(origEx.exerciseId),
            exercise_name: origEx.exercise?.name,
            sets: actualEx.sets?.length || 0,
            reps: actualEx.sets?.map(s => s.reps) || [],
            weight: actualEx.sets?.map(s => s.weight) || [],
          };
        })
        .filter(Boolean),
      endurance_sessions: originalTraining.exercises
        .filter(ex => ex.enduranceSession)
        .map(origEx => {
          const actualEx = actualTraining.exercises.find(ae => ae.exerciseId === origEx.exerciseId);
          
          if (!actualEx || !actualEx.enduranceSession) {
            return null;
          }

          return {
            id: parseInt(actualEx.enduranceSession.id),
            name: actualEx.enduranceSession.name,
            sport_type: actualEx.enduranceSession.sportType,
            training_volume: actualEx.enduranceSession.trainingVolume,
            unit: actualEx.enduranceSession.unit,
            heart_rate_zone: actualEx.enduranceSession.heartRateZone,
            intensity: actualEx.enduranceSession.intensity,
            completed: actualEx.enduranceSession.completed,
          };
        })
        .filter(Boolean),
    };

    return modifications;
  }
}

// Get historical training data for a specific exercise
export const getExerciseHistory = async (exerciseId: number, userProfileId: number): Promise<{
  success: boolean;
  data?: {
    volumeData: Array<{ date: string; volume: number }>;
    recentTrainings: Array<{ 
      date: string; 
      volume: number; 
      maxWeight: number;
      sets: number;
      reps: number[];
      weights: number[];
    }>;
    maxWeight: number;
    maxVolume: number;
  };
  error?: string;
}> => {
  try {
    console.log(`üìä Fetching exercise history for exercise ${exerciseId}, user ${userProfileId}`);
    
    // Get all COMPLETED strength exercises for this specific exercise and user
    const { data, error } = await supabase
      .from('strength_exercise')
      .select(`
        *,
        daily_training!inner(
          *,
          weekly_schedules!inner(
            training_plans!inner(
              user_profile_id
            )
          )
        )
      `)
      .eq('exercise_id', exerciseId)
      .eq('completed', true)
      .eq('daily_training.weekly_schedules.training_plans.user_profile_id', userProfileId)
      .order('updated_at', { ascending: false });

    if (error) {
      console.error('Error fetching exercise history:', error);
      return { success: false, error: error.message };
    }

    if (!data || data.length === 0) {
      console.log('No completed training data found for this exercise');
      return { 
        success: true, 
        data: {
          volumeData: [],
          recentTrainings: [],
          maxWeight: 0,
          maxVolume: 0
        }
      };
    }

    console.log(`üìä Found ${data.length} completed training records`);
    console.log(`üìä Sample data:`, data.slice(0, 2).map(d => ({
      exercise_id: d.exercise_id,
      completed: d.completed,
      weight: d.weight,
      reps: d.reps,
      sets: d.sets,
      updated_at: d.updated_at
    })));

    // Process the data
    const volumeData: Array<{ date: string; volume: number }> = [];
    const recentTrainings: Array<{ 
      date: string; 
      volume: number; 
      maxWeight: number;
      sets: number;
      reps: number[];
      weights: number[];
    }> = [];
    let maxWeight = 0;
    let maxVolume = 0;

    data.forEach((trainingExercise) => {
      const date = new Date(trainingExercise.updated_at).toISOString().split('T')[0];
      const weights = Array.isArray(trainingExercise.weight) ? trainingExercise.weight : [];
      const reps = Array.isArray(trainingExercise.reps) ? trainingExercise.reps : [];
      const sets = trainingExercise.sets || 0;
      
      console.log(`üìä Processing training:`, {
        date,
        weights,
        reps,
        sets,
        weightArray: trainingExercise.weight
      });
      
      // Calculate volume (total reps √ó total weight)
      let volume = 0;
      let trainingMaxWeight = 0;
      
      for (let i = 0; i < Math.min(weights.length, reps.length); i++) {
        const weight = weights[i] || 0;
        const rep = reps[i] || 0;
        volume += weight * rep;
        trainingMaxWeight = Math.max(trainingMaxWeight, weight);
      }
      
      console.log(`üìä Calculated: volume=${volume}, maxWeight=${trainingMaxWeight}`);
      
      maxWeight = Math.max(maxWeight, trainingMaxWeight);
      maxVolume = Math.max(maxVolume, volume);
      
      // Only add to volume data if there's actual volume (not zero)
      if (volume > 0) {
        // Add to volume data (group by date)
        const existingVolumeIndex = volumeData.findIndex(item => item.date === date);
        if (existingVolumeIndex >= 0) {
          volumeData[existingVolumeIndex].volume += volume;
        } else {
          volumeData.push({ date, volume });
        }
      }
      
      // Add to recent trainings (last 3 as requested)
      if (recentTrainings.length < 3) {
        recentTrainings.push({ 
          date, 
          volume, 
          maxWeight: trainingMaxWeight,
          sets,
          reps,
          weights
        });
      }
    });

    // Sort volume data by date
    volumeData.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());

    console.log(`üìä Found ${data.length} training records, ${volumeData.length} unique dates`);
    
    return {
      success: true,
      data: {
        volumeData,
        recentTrainings,
        maxWeight,
        maxVolume
      }
    };

  } catch (error) {
    console.error('Error fetching exercise history:', error);
    return { success: false, error: 'Failed to fetch exercise history' };
  }
};

