// Training Service - Comprehensive service for all training and training operations
import { supabase } from '../config/supabase';
import { UserProfile, TrainingPlan } from '../types';
import { API_CONFIG } from '../constants/api';
import { mapProfileToBackendRequest } from '../utils/profileDataMapping';
import { 
  GenerateTrainingPlanRequest, 
  GenerateTrainingPlanResponse,
  ApiResponse 
} from '../types/api';
import { 
  TrainingPlan as TrainingTrainingPlan, 
  DailyTraining, 
  Exercise, 
  TrainingExercise, 
  TrainingSet,
  TrainingPlanResponse,
  ExerciseResponse,
  UpdateSetResponse,
  CompleteTrainingResponse
} from '../types/training';

export interface TrainingServiceResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

export class TrainingService {
  // ============================================================================
  // WORKOUT PLAN MANAGEMENT
  // ============================================================================

  /**
   * Generate a training plan using the backend API
   */
  static async generateTrainingPlan(
    profileData: any,
    userProfileId: number,
    userId: string
  ): Promise<TrainingServiceResponse<TrainingTrainingPlan>> {
    console.log('üöÄ Generating training plan...');

    try {
      const requestBody: GenerateTrainingPlanRequest = mapProfileToBackendRequest(profileData, userId, userProfileId);

      // Get JWT token from Supabase session
      const { data: { session } } = await supabase.auth.getSession();
      const authToken = session?.access_token;

      const headers: Record<string, string> = {
        'Content-Type': 'application/json',
      };

      if (authToken) {
        headers['Authorization'] = `Bearer ${authToken}`;
      }

      const apiUrl = `${API_CONFIG.BASE_URL}${API_CONFIG.ENDPOINTS.GENERATE_WORKOUT_PLAN}`;

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers,
        body: JSON.stringify(requestBody),
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå API error:', response.status, response.statusText, errorText);
        return {
          success: false,
          error: `API Error: ${response.status} ${response.statusText}`,
        };
      }

      const result: GenerateTrainingPlanResponse = await response.json();

      if (result.status === 'success') {
        console.log('‚úÖ Training plan generated by backend');
        
        // Instead of parsing the API response, fetch the complete training plan from Supabase
        // This ensures we get all the proper IDs, relationships, and formatted data
        const trainingPlanResult = await this.getTrainingPlan(userProfileId);
        
        if (trainingPlanResult.success && trainingPlanResult.data) {
          console.log('‚úÖ Training plan fetched from database');
          return {
            success: true,
            data: trainingPlanResult.data,
          };
        } else {
          console.error('‚ùå Failed to fetch generated training plan from database');
          return {
            success: false,
            error: 'Training plan was generated but could not be retrieved',
          };
        }
      } else {
        console.error('‚ùå Generation failed - invalid response');
        return {
          success: false,
          error: result.message || 'Failed to generate training plan',
        };
      }
    } catch (error) {
      console.error('üí• Generation error:', error instanceof Error ? error.message : String(error));
      return {
        success: false,
        error: error instanceof Error ? error.message : 'An unexpected error occurred',
      };
    }
  }

  /**
   * Get training plan for a user (with proper exercise data mapping)
   */
  static async getTrainingPlan(userProfileId: number): Promise<TrainingServiceResponse<TrainingTrainingPlan>> {
    console.log('üîç TrainingService: Starting training plan fetch...', {
      userProfileId,
      timestamp: new Date().toISOString()
    });

    try {
      // First, try to fetch using relational structure
      console.log('üìä TrainingService: Attempting relational query...');
      const { data, error } = await supabase
        .from('training_plans')
        .select(`
          *,
          weekly_schedules (
            *,
            daily_trainings (
              *,
              training_exercises (
                *,
                exercises (*)
              )
            )
          )
        `)
        .eq('user_profile_id', userProfileId)
        .single();

      console.log('üìä TrainingService: Relational query result:', {
        hasData: !!data,
        hasError: !!error,
        errorCode: error?.code,
        errorMessage: error?.message,
        timestamp: new Date().toISOString()
      });

      if (error) {
        if (error.code === 'PGRST116') {
          console.log('‚ÑπÔ∏è TrainingService: No training plan found (PGRST116) - this is expected for new users');
          return {
            success: false,
            error: 'No training plan found',
          };
        }
        
        // Only log errors for actual network/database issues, not for "no data found"
        console.error('‚ùå TrainingService: Relational query failed:', error);
        console.error('‚ùå TrainingService: Error details:', {
          code: error.code,
          message: error.message,
          details: error.details,
          hint: error.hint,
          timestamp: new Date().toISOString()
        });
        
        return {
          success: false,
          error: `Database error: ${error.message}`,
        };
      }

      if (!data) {
        console.log('‚ùå TrainingService: No data returned from query');
        return { success: false, error: 'No active training plan found' };
      }

      console.log('‚úÖ TrainingService: Successfully fetched training plan data:', {
        id: data.id,
        title: data.title,
        user_profile_id: data.user_profile_id,
        has_weekly_schedules: !!data.weekly_schedules,
        weekly_schedules_count: data.weekly_schedules?.length || 0
      });

      // Debug: Check the nested data structure
      if (data.weekly_schedules && data.weekly_schedules.length > 0) {
        const firstWeek = data.weekly_schedules[0];
        console.log('üìÖ TrainingService: First week data:', {
          week_id: firstWeek.id,
          week_number: firstWeek.week_number,
          has_daily_trainings: !!firstWeek.daily_trainings,
          daily_trainings_count: firstWeek.daily_trainings?.length || 0
        });

        if (firstWeek.daily_trainings && firstWeek.daily_trainings.length > 0) {
          const firstDay = firstWeek.daily_trainings[0];
          console.log('üèÉ TrainingService: First day data:', {
            day_id: firstDay.id,
            day_of_week: firstDay.day_of_week,
            is_rest_day: firstDay.is_rest_day,
            has_training_exercises: !!firstDay.training_exercises,
            training_exercises_count: firstDay.training_exercises?.length || 0
          });

          if (firstDay.training_exercises && firstDay.training_exercises.length > 0) {
            const firstExercise = firstDay.training_exercises[0];
            console.log('üí™ TrainingService: First exercise data:', {
              training_exercise_id: firstExercise.id,
              exercise_id: firstExercise.exercise_id,
              has_exercises_data: !!firstExercise.exercises,
              exercise_name: firstExercise.exercises?.name || 'NO NAME',
              exercise_data: firstExercise.exercises
            });
          }
        }
      }

      // Transform the data to match our TrainingTrainingPlan interface
      
      const trainingPlan: TrainingTrainingPlan = {
        id: data.id.toString(),
        title: data.title,
        description: data.summary,
        totalWeeks: data.weekly_schedules?.length || 1,
        currentWeek: data.current_week,
        weeklySchedules: data.weekly_schedules?.map((schedule: any) => {
          // Sort daily trainings by day order (Monday = 0, Tuesday = 1, etc.) - Monday-first week
          const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
          const sortedDailyTrainings = schedule.daily_trainings?.sort((a: any, b: any) => {
            const aIndex = dayOrder.indexOf(a.day_of_week);
            const bIndex = dayOrder.indexOf(b.day_of_week);
            return aIndex - bIndex;
          }) || [];

          return {
            id: schedule.id.toString(),
            weekNumber: schedule.week_number,
            dailyTrainings: sortedDailyTrainings.map((daily: any) => ({
                id: daily.id.toString(),
                dayOfWeek: daily.day_of_week,
                isRestDay: daily.is_rest_day,
                exercises: daily.training_exercises?.map((we: any) => {
                const mappedExercise = {
                  id: we.id.toString(),
                  exerciseId: we.exercise_id.toString(),
                  exercise: we.exercises ? {
                    id: we.exercises.id.toString(),
                    name: we.exercises.name,
                    force: we.exercises.force,
                    instructions: we.exercises.instructions,
                    equipment: we.exercises.equipment,
                    target_area: we.exercises.target_area,
                    secondary_muscles: we.exercises.secondary_muscles,
                    main_muscles: we.exercises.main_muscles,
                    difficulty: we.exercises.difficulty,
                    exercise_tier: we.exercises.exercise_tier,
                    imageUrl: we.exercises.image_url,
                    videoUrl: we.exercises.video_url
                  } : null,
                  sets: this.parseSets(we.sets, we.reps, we.weight),
                  completed: we.completed,
                  order: we.order || 0
                };
                
                return mappedExercise;
              }) || [],
              completed: daily.training_exercises?.every((ex: any) => ex.completed) || false
            })) || [],
            completed: schedule.daily_trainings?.every((daily: any) => 
              daily.training_exercises?.every((ex: any) => ex.completed)
            ) || false,
            completedAt: schedule.completed_at ? new Date(schedule.completed_at) : undefined
          };
        }) || [],
        createdAt: new Date(data.created_at),
        updatedAt: new Date(data.updated_at),
        completed: data.completed || false,
        completedAt: data.completed_at ? new Date(data.completed_at) : undefined
      };

      return {
        success: true,
        data: trainingPlan,
      };
    } catch (error) {
      console.error('üí• TrainingService: Unexpected error fetching training plan:', error);
      return {
        success: false,
        error: 'An unexpected error occurred while fetching your training plan',
      };
    }
  }

  /**
   * Delete a training plan
   */
  static async deleteTrainingPlan(trainingPlanId: number): Promise<TrainingServiceResponse<void>> {
    try {
      const { error } = await supabase
        .from('training_plans')
        .delete()
        .eq('id', trainingPlanId);

      if (error) {
        console.error('‚ùå TrainingService: Error deleting training plan:', error);
        return {
          success: false,
          error: `Failed to delete training plan: ${error.message}`,
        };
      }

      return {
        success: true,
      };
    } catch (error) {
      console.error('üí• TrainingService: Unexpected error deleting training plan:', error);
      return {
        success: false,
        error: 'An unexpected error occurred while deleting your training plan',
      };
    }
  }

  // ============================================================================
  // EXERCISE TRACKING & WORKOUT OPERATIONS
  // ============================================================================

  /**
   * Update set details (reps, weight) for a specific exercise
   */
  static async updateSetDetails(
    exerciseId: string, 
    setIndex: number, 
    reps: number, 
    weight: number
  ): Promise<UpdateSetResponse> {
    try {
      // First, get the current training exercise data
      const { data: trainingExercise, error: fetchError } = await supabase
        .from('training_exercises')
        .select('*')
        .eq('id', exerciseId)
        .single();

      if (fetchError) {
        console.error('Error fetching training exercise:', fetchError);
        return { success: false, error: fetchError.message };
      }

      // Update the reps and weight arrays
      const updatedReps = [...trainingExercise.reps];
      const updatedWeight = [...trainingExercise.weight];
      
      updatedReps[setIndex] = reps;
      updatedWeight[setIndex] = weight;

      // Update the database
      const { data, error } = await supabase
        .from('training_exercises')
        .update({
          reps: updatedReps,
          weight: updatedWeight,
          updated_at: new Date().toISOString()
        })
        .eq('id', exerciseId)
        .select()
        .single();

      if (error) {
        console.error('Error updating set details:', error);
        return { success: false, error: error.message };
      }

      // Create the updated TrainingSet object
      const updatedSet: TrainingSet = {
        id: `${exerciseId}-${setIndex}`,
        reps: reps,
        weight: weight,
        completed: true,
        restTime: 60 // Default rest time
      };

      return { success: true, data: updatedSet };
    } catch (error) {
      console.error('Error in updateSetDetails:', error);
      return { success: false, error: 'Failed to update set details' };
    }
  }

  /**
   * Update exercise completion status in database
   */
  static async updateExerciseCompletion(exerciseId: string, completed: boolean): Promise<{ success: boolean; error?: string }> {
    try {
      const { data, error } = await supabase
        .from('training_exercises')
        .update({
          completed: completed,
          updated_at: new Date().toISOString()
        })
        .eq('id', exerciseId)
        .select()
        .single();

      if (error) {
        console.error('Error updating exercise completion:', error);
        return { success: false, error: error.message };
      }

      console.log(`‚úÖ Exercise ${exerciseId} completion updated to: ${completed}`);
      return { success: true };
    } catch (error) {
      console.error('Error in updateExerciseCompletion:', error);
      return { success: false, error: 'Failed to update exercise completion' };
    }
  }

  /**
   * Toggle exercise completion status (DEPRECATED - now handled in frontend)
   * This function is kept for backward compatibility but is no longer used
   */
  static async toggleExerciseCompletion(exerciseId: string): Promise<{ success: boolean; error?: string }> {
    console.warn('toggleExerciseCompletion is deprecated - exercise completion is now handled in frontend');
    return { success: true };
  }


  /**
   * Complete a daily training
   */
  static async completeDailyTraining(
    dailyTrainingId: string
  ): Promise<CompleteTrainingResponse> {
    try {
      const { data, error } = await supabase
        .from('daily_trainings')
        .update({
          updated_at: new Date().toISOString()
        })
        .eq('id', dailyTrainingId)
        .select()
        .single();

      if (error) {
        console.error('Error completing daily training:', error);
        return { success: false, error: error.message };
      }

      return { 
        success: true, 
        data: {
          trainingId: dailyTrainingId
        }
      };
    } catch (error) {
      console.error('Error in completeDailyTraining:', error);
      return { success: false, error: 'Failed to complete daily training' };
    }
  }

  /**
   * Get exercise details by ID
   */
  static async getExerciseDetails(exerciseId: string): Promise<ExerciseResponse> {
    try {
      const { data, error } = await supabase
        .from('exercises')
        .select('*')
        .eq('id', exerciseId)
        .single();

      if (error) {
        console.error('Error fetching exercise details:', error);
        return { success: false, error: error.message };
      }

      const exercise: Exercise = {
        id: data.id.toString(),
        name: data.name,
        force: data.force,
        instructions: data.instructions,
        equipment: data.equipment,
        target_area: data.target_area,
        secondary_muscles: data.secondary_muscles,
        main_muscles: data.main_muscles,
        difficulty: data.difficulty,
        imageUrl: data.image_url,
        videoUrl: data.video_url
      };

      return { success: true, data: [exercise] };
    } catch (error) {
      console.error('Error in getExerciseDetails:', error);
      return { success: false, error: 'Failed to fetch exercise details' };
    }
  }

  /**
   * Get training history for a user
   */
  static async getTrainingHistory(userId: string, limit: number = 10): Promise<{ success: boolean; data?: DailyTraining[]; error?: string }> {
    try {
      const { data, error } = await supabase
        .from('daily_trainings')
        .select(`
          *,
          training_exercises (
            *,
            exercises (*)
          )
        `)
        .eq('completed', true)
        .order('completed_at', { ascending: false })
        .limit(limit);

      if (error) {
        console.error('Error fetching training history:', error);
        return { success: false, error: error.message };
      }

      const history: DailyTraining[] = data.map((daily: any) => ({
        id: daily.id.toString(),
        dayOfWeek: daily.day_of_week,
        isRestDay: daily.is_rest_day,
        exercises: daily.training_exercises.map((we: any) => ({
          id: we.id.toString(),
          exerciseId: we.exercise_id.toString(),
          exercise: {
            id: we.exercises.id.toString(),
            name: we.exercises.name,
            force: we.exercises.force,
            instructions: we.exercises.instructions,
            equipment: we.exercises.equipment,
            target_area: we.exercises.target_area,
            secondary_muscles: we.exercises.secondary_muscles,
            main_muscles: we.exercises.main_muscles,
            difficulty: we.exercises.difficulty,
            imageUrl: we.exercises.image_url,
            videoUrl: we.exercises.video_url
          },
          sets: this.parseSets(we.sets, we.reps, we.weight),
          completed: we.completed,
          order: we.order || 0
        })),

      }));

      return { success: true, data: history };
    } catch (error) {
      console.error('Error in getTrainingHistory:', error);
      return { success: false, error: 'Failed to fetch training history' };
    }
  }

  // ============================================================================
  // HOME SCREEN DATA METHODS
  // ============================================================================

  /**
   * Get training streak (consecutive days with completed trainings)
   */
  static async getTrainingStreak(userProfileId: number): Promise<TrainingServiceResponse<number>> {
    try {
      // Get training plan with relational data
      const { data: trainingPlan, error } = await supabase
        .from('training_plans')
        .select(`
          *,
          weekly_schedules (
            *,
            daily_trainings (
              *,
              training_exercises (
                *,
                exercises (*)
              )
            )
          )
        `)
        .eq('user_profile_id', userProfileId)
        .single();

      if (error || !trainingPlan) {
        return { success: true, data: 0 };
      }

      // Calculate streak from relational data across all weeks
      let streak = 0;
      const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
      
      if (!trainingPlan.weekly_schedules || trainingPlan.weekly_schedules.length === 0) {
        console.log('‚ùå getTrainingStreak - No weekly schedules found');
        return { success: true, data: 0 };
      }

      // Get all daily trainings from all weeks, sorted by week number and day order
      const allTrainings: any[] = [];
      
      trainingPlan.weekly_schedules
        .sort((a: any, b: any) => b.week_number - a.week_number) // Most recent week first
        .forEach((week: any) => {
          if (week.daily_trainings) {
            // Sort daily trainings by day order (most recent first within each week)
            const sortedDailyTrainings = week.daily_trainings.sort((a: any, b: any) => {
              const aIndex = dayOrder.indexOf(a.day_of_week);
              const bIndex = dayOrder.indexOf(b.day_of_week);
              return bIndex - aIndex;
            });
            
            allTrainings.push(...sortedDailyTrainings);
          }
        });

      // Calculate streak by going through all trainings chronologically
      for (const training of allTrainings) {
        if (training.is_rest_day) continue; // Skip rest days
        
        // Check if all exercises in this training are completed
        const allExercisesCompleted = training.training_exercises?.every((ex: any) => ex.completed);
        
        if (allExercisesCompleted) {
          streak++;
        } else {
          break; // Streak broken - stop counting
        }
      }

      return { success: true, data: streak };
    } catch (error) {
      console.error('üí• TrainingService: Error calculating streak:', error);
      return { success: false, error: 'Failed to calculate training streak' };
    }
  }

  /**
   * Get weekly training count (total planned trainings in current week)
   */
  static async getWeeklyTrainingCount(userProfileId: number): Promise<TrainingServiceResponse<number>> {
    try {
      // Get training plan with relational data
      const { data: trainingPlan, error } = await supabase
        .from('training_plans')
        .select(`
          *,
          weekly_schedules (
            *,
            daily_trainings (
              *,
              training_exercises (
                *,
                exercises (*)
              )
            )
          )
        `)
        .eq('user_profile_id', userProfileId)
        .single();

      if (error || !trainingPlan) {
        return { success: true, data: 0 };
      }

      // Get current week's schedule
      const targetWeek = trainingPlan.current_week || 1;
      const currentWeek = trainingPlan.weekly_schedules?.find((week: any) => 
        week.week_number === targetWeek
      );
      
      if (!currentWeek?.daily_trainings) {
        return { success: true, data: 0 };
      }

      // Count all planned trainings in current week (non-rest days)
      const totalTrainings = currentWeek.daily_trainings.filter((training: any) => !training.is_rest_day).length;
      return { success: true, data: totalTrainings };
    } catch (error) {
      console.error('üí• TrainingService: Error calculating weekly trainings:', error);
      return { success: false, error: 'Failed to calculate weekly training count' };
    }
  }

  /**
   * Get goal progress (percentage of completed trainings)
   */
  static async getGoalProgress(userProfileId: number): Promise<TrainingServiceResponse<number>> {
    try {
      // Get training plan with relational data
      const { data: trainingPlan, error } = await supabase
        .from('training_plans')
        .select(`
          *,
          weekly_schedules (
            *,
            daily_trainings (
              *,
              training_exercises (
                *,
                exercises (*)
              )
            )
          )
        `)
        .eq('user_profile_id', userProfileId)
        .single();

      if (error || !trainingPlan) {
        return { success: true, data: 0 };
      }

      // Get current week's schedule
      const targetWeek = trainingPlan.current_week || 1;
      const currentWeek = trainingPlan.weekly_schedules?.find((week: any) => 
        week.week_number === targetWeek
      );
      
      if (!currentWeek?.daily_trainings) {
        return { success: true, data: 0 };
      }

      const totalTrainingDays = currentWeek.daily_trainings.filter((training: any) => !training.is_rest_day).length;
      const completedTrainingDays = currentWeek.daily_trainings.filter((training: any) => {
        if (training.is_rest_day) return false;
        return training.training_exercises?.every((ex: any) => ex.completed);
      }).length;

      const progress = totalTrainingDays > 0 ? Math.round((completedTrainingDays / totalTrainingDays) * 100) : 0;
      return { success: true, data: progress };
    } catch (error) {
      console.error('üí• TrainingService: Error calculating goal progress:', error);
      return { success: false, error: 'Failed to calculate goal progress' };
    }
  }

  /**
   * Get today's training with exercises
   */
  static async getTodaysTraining(userProfileId: number): Promise<TrainingServiceResponse<any>> {
    try {
      const today = new Date();
      const dayNames = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
      const todayName = dayNames[today.getDay()];

      // Get training plan with relational data
      const { data: trainingPlan, error } = await supabase
        .from('training_plans')
        .select(`
          *,
          weekly_schedules (
            *,
            daily_trainings (
              *,
              training_exercises (
                *,
                exercises (*)
              )
            )
          )
        `)
        .eq('user_profile_id', userProfileId)
        .single();

      if (error || !trainingPlan) {
        console.log('‚ÑπÔ∏è No training plan found');
        return { success: true, data: null };
      }

      // Get current week's schedule - fallback to first week if current_week is undefined
      const targetWeek = trainingPlan.current_week || 1;
      
      const currentWeek = trainingPlan.weekly_schedules?.find((week: any) => 
        week.week_number === targetWeek
      );
      
      if (!currentWeek?.daily_trainings) {
        console.log('‚ùå getTodaysTraining - No current week or daily trainings found');
        return { success: true, data: null };
      }

      // Find today's training
      const todaysTraining = currentWeek.daily_trainings.find((training: any) => 
        training.day_of_week === todayName
      );

      if (!todaysTraining) {
        return { success: true, data: null };
      }

      // Transform the data to match component expectations
      const transformedTraining = {
        id: todaysTraining.id || todayName,
        name: `${todayName} Training`,
        isRestDay: todaysTraining.is_rest_day,
        exercises: todaysTraining.training_exercises?.map((trainingExercise: any) => ({
          id: trainingExercise.id?.toString() || Math.random().toString(),
          name: trainingExercise.exercises?.name || 'Unknown Exercise',
          completed: trainingExercise.completed || false,
          sets: trainingExercise.sets || 1,
          reps: trainingExercise.reps || [10],
          weight: trainingExercise.weight || [null],
          weight1rm: trainingExercise.weight_1rm || [70],
        })) || [],
      };

      return { success: true, data: transformedTraining };
    } catch (error) {
      console.error('üí• TrainingService: Error fetching today\'s training:', error);
      return { success: false, error: 'Failed to fetch today\'s training' };
    }
  }

  /**
   * Get recent completed trainings (last 3)
   */
  static async getRecentActivity(userProfileId: number): Promise<TrainingServiceResponse<any[]>> {
    try {
      // Get training plan with relational data
      const { data: trainingPlan, error } = await supabase
        .from('training_plans')
        .select(`
          *,
          weekly_schedules (
            *,
            daily_trainings (
              *,
              training_exercises (
                *,
                exercises (*)
              )
            )
          )
        `)
        .eq('user_profile_id', userProfileId)
        .single();

      if (error || !trainingPlan) {
        return { success: true, data: [] };
      }

      // Get current week's schedule
      const targetWeek = trainingPlan.current_week || 1;
      const currentWeek = trainingPlan.weekly_schedules?.find((week: any) => 
        week.week_number === targetWeek
      );
      
      if (!currentWeek?.daily_trainings) {
        return { success: true, data: [] };
      }

      // Filter and transform completed trainings (only where ALL exercises are completed)
      const dayOrder = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
      
      const recentActivities = currentWeek.daily_trainings
        .filter((training: any) => {
          // Only get training days, not rest days
          if (training.is_rest_day) return false;
          
          // Check if all exercises in this training are completed
          return training.training_exercises?.every((ex: any) => ex.completed);
        })
        .sort((a: any, b: any) => {
          // Sort by day order (most recent first)
          const aIndex = dayOrder.indexOf(a.day_of_week);
          const bIndex = dayOrder.indexOf(b.day_of_week);
          return bIndex - aIndex;
        })
        .slice(0, 3) // Take only last 3 completed trainings
        .map((training: any, index: number) => ({
          id: training.id?.toString() || training.day_of_week,
          type: 'training' as const,
          title: `${training.day_of_week} Training`,
          subtitle: `${training.training_exercises?.length || 0} exercises ‚Ä¢ 45 minutes ‚Ä¢ 320 calories`, // Dummy data as requested
          date: index === 0 ? 'Yesterday' : index === 1 ? '2 days ago' : '3 days ago',
          duration: '45 min',
          calories: 320,
        }));

      return { success: true, data: recentActivities };
    } catch (error) {
      console.error('üí• TrainingService: Error fetching recent activity:', error);
      return { success: false, error: 'Failed to fetch recent activity' };
    }
  }

  // ============================================================================
  // UTILITY METHODS
  // ============================================================================

  /**
   * Helper method to parse sets from database arrays
   */
  private static parseSets(setsCount: number, reps: number[], weight: number[]): TrainingSet[] {
    const sets: TrainingSet[] = [];
    for (let i = 0; i < setsCount; i++) {
      sets.push({
        id: `set-${i}`,
        reps: reps[i] || 0,
        weight: weight[i] || 0,
        completed: reps[i] > 0 && weight[i] > 0,
        restTime: 60
      });
    }
    return sets;
  }

  /**
   * Calculate 1RM using Epley formula
   */
  static calculateOneRM(weight: number, reps: number): number {
    if (reps <= 0 || weight <= 0) return 0;
    if (reps === 1) return weight;
    
    // Epley formula: 1RM = weight * (1 + reps/30)
    return Math.round(weight * (1 + reps / 30));
  }

  /**
   * Calculate training progress percentage
   */
  static calculateTrainingProgress(exercises: TrainingExercise[]): number {
    if (exercises.length === 0) return 0;
    
    const completedExercises = exercises.filter(ex => ex.completed).length;
    return Math.round((completedExercises / exercises.length) * 100);
  }

  /**
   * Calculate weekly progress
   */
  static calculateWeeklyProgress(dailyTrainings: DailyTraining[]): number {
    if (dailyTrainings.length === 0) return 0;
    
    const completedTrainings = dailyTrainings.filter(training => training.completed).length;
    return Math.round((completedTrainings / dailyTrainings.length) * 100);
  }
}

// Get historical training data for a specific exercise
export const getExerciseHistory = async (exerciseId: number, userProfileId: number): Promise<{
  success: boolean;
  data?: {
    volumeData: Array<{ date: string; volume: number }>;
    recentTrainings: Array<{ 
      date: string; 
      volume: number; 
      maxWeight: number;
      sets: number;
      reps: number[];
      weights: number[];
    }>;
    maxWeight: number;
    maxVolume: number;
  };
  error?: string;
}> => {
  try {
    console.log(`üìä Fetching exercise history for exercise ${exerciseId}, user ${userProfileId}`);
    
    // Get all COMPLETED training exercises for this specific exercise and user
    const { data, error } = await supabase
      .from('training_exercises')
      .select(`
        *,
        daily_trainings!inner(
          *,
          weekly_schedules!inner(
            training_plans!inner(
              user_profile_id
            )
          )
        )
      `)
      .eq('exercise_id', exerciseId)
      .eq('completed', true)
      .eq('daily_trainings.weekly_schedules.training_plans.user_profile_id', userProfileId)
      .order('updated_at', { ascending: false });

    if (error) {
      console.error('Error fetching exercise history:', error);
      return { success: false, error: error.message };
    }

    if (!data || data.length === 0) {
      console.log('No completed training data found for this exercise');
      return { 
        success: true, 
        data: {
          volumeData: [],
          recentTrainings: [],
          maxWeight: 0,
          maxVolume: 0
        }
      };
    }

    console.log(`üìä Found ${data.length} completed training records`);
    console.log(`üìä Sample data:`, data.slice(0, 2).map(d => ({
      exercise_id: d.exercise_id,
      completed: d.completed,
      weight: d.weight,
      reps: d.reps,
      sets: d.sets,
      updated_at: d.updated_at
    })));

    // Process the data
    const volumeData: Array<{ date: string; volume: number }> = [];
    const recentTrainings: Array<{ 
      date: string; 
      volume: number; 
      maxWeight: number;
      sets: number;
      reps: number[];
      weights: number[];
    }> = [];
    let maxWeight = 0;
    let maxVolume = 0;

    data.forEach((trainingExercise) => {
      const date = new Date(trainingExercise.updated_at).toISOString().split('T')[0];
      const weights = Array.isArray(trainingExercise.weight) ? trainingExercise.weight : [];
      const reps = Array.isArray(trainingExercise.reps) ? trainingExercise.reps : [];
      const sets = trainingExercise.sets || 0;
      
      console.log(`üìä Processing training:`, {
        date,
        weights,
        reps,
        sets,
        weightArray: trainingExercise.weight
      });
      
      // Calculate volume (total reps √ó total weight)
      let volume = 0;
      let trainingMaxWeight = 0;
      
      for (let i = 0; i < Math.min(weights.length, reps.length); i++) {
        const weight = weights[i] || 0;
        const rep = reps[i] || 0;
        volume += weight * rep;
        trainingMaxWeight = Math.max(trainingMaxWeight, weight);
      }
      
      console.log(`üìä Calculated: volume=${volume}, maxWeight=${trainingMaxWeight}`);
      
      maxWeight = Math.max(maxWeight, trainingMaxWeight);
      maxVolume = Math.max(maxVolume, volume);
      
      // Only add to volume data if there's actual volume (not zero)
      if (volume > 0) {
        // Add to volume data (group by date)
        const existingVolumeIndex = volumeData.findIndex(item => item.date === date);
        if (existingVolumeIndex >= 0) {
          volumeData[existingVolumeIndex].volume += volume;
        } else {
          volumeData.push({ date, volume });
        }
      }
      
      // Add to recent trainings (last 3 as requested)
      if (recentTrainings.length < 3) {
        recentTrainings.push({ 
          date, 
          volume, 
          maxWeight: trainingMaxWeight,
          sets,
          reps,
          weights
        });
      }
    });

    // Sort volume data by date
    volumeData.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());

    console.log(`üìä Found ${data.length} training records, ${volumeData.length} unique dates`);
    
    return {
      success: true,
      data: {
        volumeData,
        recentTrainings,
        maxWeight,
        maxVolume
      }
    };

  } catch (error) {
    console.error('Error fetching exercise history:', error);
    return { success: false, error: 'Failed to fetch exercise history' };
  }
};

