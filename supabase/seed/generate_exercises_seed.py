#!/usr/bin/env python3
"""
Generate exercises_seed.sql from exercises_rows (1).csv

This script reads the CSV file and generates SQL INSERT statements
for seeding the exercises table in Supabase.
"""

import csv
import json
import os
from pathlib import Path

def parse_array_field(value):
    """Parse array field from CSV (can be JSON array string or empty)"""
    if not value or value.strip() == '':
        return 'ARRAY[]::text[]'
    
    # Try to parse as JSON array
    try:
        arr = json.loads(value)
        if isinstance(arr, list):
            # Escape single quotes and format as PostgreSQL array
            escaped_items = []
            for item in arr:
                if item:
                    # Escape single quotes by doubling them
                    escaped_item = item.replace("'", "''")
                    escaped_items.append(f"'{escaped_item}'")
            return f"ARRAY[{', '.join(escaped_items)}]::text[]"
    except (json.JSONDecodeError, TypeError):
        pass
    
    # If not valid JSON, treat as empty array
    return 'ARRAY[]::text[]'

def escape_sql_string(value):
    """Escape single quotes for SQL strings"""
    if value is None:
        return 'NULL'
    # Escape single quotes by doubling them
    escaped = str(value).replace("'", "''")
    return f"'{escaped}'"

def generate_sql_insert(row):
    """Generate a single INSERT statement from a CSV row"""
    # Parse array fields
    main_muscles = parse_array_field(row.get('main_muscles', ''))
    secondary_muscles = parse_array_field(row.get('secondary_muscles', ''))
    alternative_names = parse_array_field(row.get('alternative_names', ''))
    
    # Handle nullable text fields
    preparation = escape_sql_string(row.get('preparation')) if row.get('preparation') else 'NULL'
    execution = escape_sql_string(row.get('execution')) if row.get('execution') else 'NULL'
    tips = escape_sql_string(row.get('tips')) if row.get('tips') else 'NULL'
    
    # Handle required fields
    name = escape_sql_string(row.get('name', ''))
    equipment = escape_sql_string(row.get('equipment', ''))
    target_area = escape_sql_string(row.get('target_area', ''))
    force = escape_sql_string(row.get('force', ''))
    difficulty = escape_sql_string(row.get('difficulty', ''))
    tier = escape_sql_string(row.get('tier', ''))
    popularity_score = row.get('popularity_score', '0')
    
    # Handle timestamps
    created_at = escape_sql_string(row.get('created_at')) if row.get('created_at') else 'NOW()'
    updated_at = escape_sql_string(row.get('updated_at')) if row.get('updated_at') else 'NOW()'
    
    # Generate INSERT statement
    # Note: id is SERIAL (auto-generated), so we don't insert it
    # Seed files run on db reset which clears tables, so no ON CONFLICT needed
    sql = f"""INSERT INTO public.exercises (
    name,
    equipment,
    target_area,
    force,
    difficulty,
    tier,
    popularity_score,
    main_muscles,
    secondary_muscles,
    preparation,
    execution,
    tips,
    created_at,
    updated_at,
    alternative_names
) VALUES (
    {name},
    {equipment},
    {target_area},
    {force},
    {difficulty},
    {tier},
    {popularity_score},
    {main_muscles},
    {secondary_muscles},
    {preparation},
    {execution},
    {tips},
    {created_at}::timestamp with time zone,
    {updated_at}::timestamp with time zone,
    {alternative_names}
);"""
    
    return sql

def main():
    # Get script directory
    script_dir = Path(__file__).parent
    
    # Paths
    csv_path = script_dir / "exercises_rows (1).csv"
    output_path = script_dir / "exercises_seed.sql"
    
    if not csv_path.exists():
        print(f"Error: CSV file not found at {csv_path}")
        return 1
    
    print(f"Reading CSV from: {csv_path}")
    print(f"Writing SQL to: {output_path}")
    
    # Read CSV and generate SQL
    sql_statements = []
    sql_statements.append("-- Seed exercises from CSV")
    sql_statements.append("-- This file is automatically generated by generate_exercises_seed.py")
    sql_statements.append("-- Do not edit manually - regenerate using the Python script")
    sql_statements.append("")
    
    with open(csv_path, 'r', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        row_count = 0
        
        for row in reader:
            sql = generate_sql_insert(row)
            sql_statements.append(sql)
            sql_statements.append("")
            row_count += 1
        
        print(f"Processed {row_count} exercises")
    
    # Write SQL file
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write('\n'.join(sql_statements))
    
    print(f"âœ… Generated {output_path} with {row_count} INSERT statements")
    return 0

if __name__ == '__main__':
    exit(main())
